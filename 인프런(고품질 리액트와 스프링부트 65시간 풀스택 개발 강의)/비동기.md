# 자바스크립트 비동기 프로그래밍 핵심 개념 정리

## 1. 비동기 처리의 필요성과 문제점

### 왜 비동기가 필요한가?
- 서버에서 데이터를 가져오는 작업은 시간이 걸림
- 동기적으로 처리하면 UI가 멈춤 (blocking)
- 사용자 경험을 위해 비동기 처리가 필수

### 초기 비동기 처리의 한계
- **콜백 지옥(Callback Hell)**: 중첩된 콜백으로 인한 코드 복잡성
- **에러 처리의 어려움**: try-catch로 비동기 에러를 잡을 수 없음
- **가독성 저하**: 코드 흐름을 따라가기 어려움

## 2. Promise - 비동기 처리의 혁명

### Promise의 핵심 개념
```javascript
// Promise 기본 구조
const orderPizza = () => {
  return new Promise((resolve, reject) => {
    // 비동기 작업
    if (success) {
      resolve(result); // 성공시
    } else {
      reject(error);   // 실패시
    }
  });
};
```

### Promise의 장점
- **체이닝**: `.then()`, `.catch()`, `.finally()`로 연결 가능
- **에러 처리**: `.catch()`로 일관된 에러 처리
- **상태 관리**: pending → fulfilled/rejected 명확한 상태

### Promise 체이닝 예제
```javascript
orderPizza()
  .then(result => {
    console.log('피자 주문 성공');
    return deliverPizza();
  })
  .then(delivery => {
    console.log('피자 배달 완료');
  })
  .catch(error => {
    console.log('오류 발생:', error);
  });
```

## 3. Async/Await - 동기처럼 보이는 비동기

### Async/Await의 혁신
- Promise를 **동기 코드처럼** 작성 가능
- **가독성 대폭 향상**
- **직관적인 에러 처리**

### 기본 사용법
```javascript
async function orderAndWait() {
  try {
    const pizza = await orderPizza();
    const delivery = await deliverPizza(pizza);
    console.log('모든 작업 완료');
  } catch (error) {
    console.log('에러 발생:', error);
  }
}
```

### Async Function의 특징
- 항상 **Promise를 반환**
- `await`은 async 함수 내부에서만 사용 가능
- `await`은 Promise가 resolve될 때까지 **일시 정지**

## 4. 비동기 처리 방식 비교

### 콜백 vs Promise vs Async/Await

**콜백 (Callback)**
```javascript
getData(function(err, data1) {
  if (err) throw err;
  processData(data1, function(err, data2) {
    if (err) throw err;
    // 콜백 지옥...
  });
});
```

**Promise**
```javascript
getData()
  .then(data1 => processData(data1))
  .then(data2 => console.log(data2))
  .catch(err => console.log(err));
```

**Async/Await**
```javascript
async function handleData() {
  try {
    const data1 = await getData();
    const data2 = await processData(data1);
    console.log(data2);
  } catch (err) {
    console.log(err);
  }
}
```

## 5. 실전 활용 팁

### Fetch API와 Async/Await
```javascript
async function fetchUserData() {
  try {
    const response = await fetch('/api/users');
    
    if (!response.ok) {
      throw new Error('네트워크 오류');
    }
    
    const userData = await response.json();
    return userData;
    
  } catch (error) {
    console.error('데이터 가져오기 실패:', error);
    throw error; // 상위로 에러 전파
  }
}
```

### 병렬 처리 vs 순차 처리
```javascript
// 순차 처리 (느림)
const data1 = await fetch('/api/data1');
const data2 = await fetch('/api/data2');

// 병렬 처리 (빠름)
const [data1, data2] = await Promise.all([
  fetch('/api/data1'),
  fetch('/api/data2')
]);
```

## 6. 주요 포인트 요약

### 개발자가 알아야 할 핵심
1. **Promise는 비동기 작업의 완료/실패를 나타내는 객체**
2. **Async/Await는 Promise의 문법적 설탕(Syntactic Sugar)**
3. **에러 처리는 try-catch 또는 .catch()로 일관되게**
4. **비동기 작업의 순차/병렬 실행을 구분해서 사용**
5. **항상 에러 상황을 고려한 defensive 코딩**

### 실무에서 자주 하는 실수
- `await` 없이 Promise 객체 직접 사용
- 비동기 함수에서 동기적 에러 처리 시도
- 불필요한 순차 처리로 인한 성능 저하
- 에러 처리 누락으로 인한 Unhandled Promise Rejection

**결론**: 비동기 프로그래밍은 현대 웹 개발의 필수 요소이며, Promise와 Async/Await를 제대로 이해하면 더 안정적이고 효율적인 코드를 작성할 수 있습니다.